from pydantic import BaseModel, Field, RootModel  # Import RootModel
from typing import Dict, List, Optional
import json
from llama_index.core.workflow import (
    Event,
    StartEvent,
    StopEvent,
    Workflow,
    step,
)
import asyncio
from config_loader import load_shared_resources
from llama_index.llms.gemini import Gemini

config, embed_model = load_shared_resources()
llm = Gemini(
    api_key=config.get("gemini_api_key") or config.get("GEMINI_API_KEY") or config.get("GEMINI_API"), 
    model_name=config.get("llm_model")
)

def load_json_file(file_path):
    """Loads JSON data from a file."""
    try:
        with open(file_path, 'r') as f:
            return json.load(f)
    except FileNotFoundError:
        print(f"Error: JSON file not found at '{file_path}'")
        return None
    except json.JSONDecodeError:
        print(f"Error: Could not decode JSON from file '{file_path}'. Please ensure it is valid JSON.")
        return None

class unit_abilities(RootModel):  # Back to RootModel
    """Pydantic model for Abilities within a Learning Unit."""
    root: Dict[str, str] # Root is directly a dictionary

class unit_knowledge(RootModel):  # Back to RootModel
    """Pydantic model for Knowledge within a Learning Unit."""
    root: Dict[str, str] # Root is directly a dictionary


class LearningUnitDetails(BaseModel):
    """Pydantic model for details of a single Learning Unit."""
    LO: str = Field(..., description="Learning Objective for the Learning Unit.")
    Abilities: unit_abilities = Field(..., description="Abilities associated with the Learning Unit.") # Renamed field
    Knowledge: unit_knowledge = Field(..., description="Knowledge associated with the Learning Unit.") # Renamed field
    Keywords: List[str] = Field(default_factory=list, description="Keywords for retrieval related to this Learning Unit.")
    Retrieval_Metadata: Optional[str] = Field(default=None, description="Metadata for retrieval.")
    Question: Optional[str] = Field(default=None, description="Question derived from the LU for RAG.")
    Answer: Optional[str] = Field(default=None, description="Answer generated by RAG for the Question.")

class LearningUnits(RootModel): # LearningUnits can still be RootModel if you want it to be the root dictionary
    """Pydantic model for the entire structure of Learning Units."""
    root: Dict[str, LearningUnitDetails]

# Example usage and parsing (assuming your data is in a dictionary called `lu_data`)
lu_data = load_json_file("output_json/parsed_TSC.json")

# Parse the dictionary into the Pydantic model
learning_units = LearningUnits.parse_obj(lu_data) # Use .parse_obj for RootModel

# Define a custom Event class to hold Learning Unit data
class LUDataEvent(Event): # Inherit from Event
    lu_details: LearningUnitDetails

# # Loop through each Learning Unit and print its details
# for lu_name, lu_details in learning_units.root.items(): # Iterate through items (key-value pairs)
#     print(f"Learning Unit: {lu_name}")
#     print(f"Learning Unit Details: {lu_details}")
#     # print(f"  LO: {lu_details.LO}")
#     # print(f"  Abilities: {lu_details.Abilities.root}") # Access abilities dictionary via .root
#     # print(f"  Knowledge: {lu_details.Knowledge.root}") # Access knowledge dictionary via .root
#     # print(f"  Keywords: {lu_details.Keywords}")
#     # print(f"  Question: {lu_details.Question}")
#     # print(f"  Answer: {lu_details.Answer}")
#     print("-" * 30) # Separator for readability
# # Accessing data (with RootModel for Abilities and Knowledge, field names match JSON)
# lu1_details = learning_units.root["LU1: Git and GitHub Fundamentals (A1, A2)"] # No change for accessing LearningUnits root
# print(f"Learning Unit 1 LO: {lu1_details.LO}")
# print(f"Ability A1: {lu1_details.Abilities.root['A1']}") # Access via .Abilities.root (matches JSON structure)
# print(f"Knowledge K1: {lu1_details.Knowledge.root.get('K1', 'N/A')}") # Safely access Knowledge dict, handle missing K1
# print(f"Keywords for LU1 (initially empty): {lu1_details.Keywords}")

# # Example of setting Keywords, Question, Answer (no changes needed here for these fields)
# lu1_details.Keywords = ["Git", "GitHub", "Fundamentals", "Version Control", "Release Scheduling"]
# lu1_details.Question = "Explain the fundamentals of Git and GitHub and how to coordinate release scheduling with collaborators."
# lu1_details.Answer = "This is where the RAG answer would go after querying..."

# print(f"Keywords for LU1 (after setting): {lu1_details.Keywords}")
# print(f"Question for LU1: {lu1_details.Question}")
# print(f"Answer for LU1: {lu1_details.Answer}")

class PydanticWorkflow(Workflow):
    llm = llm # Initialize LLM in the Workflow class

    @step
    async def first_step(self, ev: StartEvent) -> LUDataEvent: # First step takes StartEvent
        lu_details = ev.lu_details # Access lu_details from StartEvent (passed from main())

        # LLM Keyword Generation Prompt
        prompt_keywords = f"""Generate 5-7 keywords that are highly relevant to the following Learning Unit.
        Keywords should be concise and capture the core concepts.

        Learning Objective: {lu_details.LO}
        Abilities: {lu_details.Abilities.root}
        Knowledge: {lu_details.Knowledge.root}

        Keywords:"""

        # Call LLM to generate keywords
        response = await self.llm.acomplete(prompt_keywords) # Use await for async LLM call
        generated_keywords = response.text.strip().split(", ") # Simple split, refine as needed

        # Update LearningUnitDetails with generated keywords
        lu_details.Keywords = generated_keywords # Update the Keywords list

        print(f"Generated Keywords for {lu_details.Keywords}") # Print generated keywords

        # First step now *receives*, *updates*, and packages the data into LUDataEvent
        return LUDataEvent(lu_details=lu_details)

    @step
    async def second_step(self, event: LUDataEvent) -> StopEvent: # Second step takes LUDataEvent
        lu_details = event.lu_details

        print(f"Learning Unit Details - LO: {lu_details.LO}")
        print(f"Learning Unit Details - Abilities: {lu_details.Abilities.root}")
        print(f"Learning Unit Details - Knowledge: {lu_details.Knowledge.root}")
        print(f"Learning Unit Details - Keywords (Updated by LLM): {lu_details.Keywords}") # Print updated keywords
        print(f"Learning Unit Details - Question: {lu_details.Question}")
        print(f"Learning Unit Details - Answer: {lu_details.Answer}")
        print("-" * 30)
        return StopEvent()

async def main():
    # Load data *once* outside the workflow loop
    lu_data = load_json_file("output_json/parsed_TSC.json")
    learning_units = LearningUnits.parse_obj(lu_data)

    # Loop through each Learning Unit and run a *new* workflow for each
    for lu_name, lu_details in learning_units.root.items():
        w = PydanticWorkflow(timeout=60, verbose=False) # New workflow instance, increased timeout
        # Pass lu_name and lu_details directly in StartEvent in w.run()
        result = await w.run(lu_details=lu_details) # Pass data in StartEvent
        print(f"Workflow Result for {lu_name}: {result}") # Print workflow result (optional)


if __name__ == "__main__":
    import asyncio
    asyncio.run(main())